---
title: dplyr
author: Andrew Barr
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

```{r setup, echo=FALSE}
library(learnr)
loans<-read.table("https://stats.are-awesome.com/datasets/DMV_2014_Q3_Undergrad_DirectLoans.txt", header=T, sep=",")
```

## the `tidyverse`

###

`tidyverse` is a series of R packages that has revolutionized working with data in R. This week we will be using one of the packages in the `tidyverse` called `dplyr`, which provides a consistent and simple interface to do common data manipulation tasks.

Next week, we will focus on another of the `tidyverse` packages called `ggplot2` which is useful for making graphs and figures. 

### the dplyr package

`dplyr` is a package within the tidyverse for manipulating dataframes.  It is very consistent. 

`dplyr` assumes that you are starting with a dataframe, doing something to that dataframe, and finishing with a different dataframe. 

Many of the base R functions operate on atomic vectors, which makes it more complicated to apply them to dataframes.

`dplyr` introduces a series of simple 'verbs' that describe many common data manipulation tasks. 

## main dataset for tutorial

We will be using a dataset on student loans in public and private universities.  [DMV_2014_Q3_Undergrad_DirectLoans.txt](stats.are-awesome.com/datasets/DMV_2014_Q3_Undergrad_DirectLoans.txt)

We can read it in using `read.table()` and save it to a variable called `loans`. The same `read.table()` function can deal with local and remote data sources. You can modify this code in your own work to read data from remote sources (i.e. files from the internet), or to read data from your own computer.   

```{r readdata}
## notice how first we define a variable called theURL and then pass this variable to the read.table() function
## this is an optional extra step, but makes the code more readable for humans
theURL <- 'https://stats.are-awesome.com/datasets/DMV_2014_Q3_Undergrad_DirectLoans.txt'
loans<-read.table(theURL, header=T, sep=",")
```


## The basic dplyr verbs

###

There are a few basic functions in `dplyr`, which are all verbs which describe their action. 

The first argument to these functions is always the dataframe that you want to manipulate. 

Within these function calls, you can refer to the names of columns in the dataframe WITHOUT quotation marks and WITHOUT the usual `$` syntax. This is cool and makes it easier to type your commands!

Here, we first load the `dplyr` package to get access to these functions, which are not available in R by default (they live in the `dplyr` package). 

Once you load a package, the functions defined in that package are available to you during your current R session, or in subsequent lines of an R script.  

```{r warning=FALSE, message=FALSE}
library(dplyr)
```

**Note:** If you don't want to load ALL the functions in a particular library, you can invoke functions individually by referring to them like this `packageName::functionName`, but most commonly you will load the entire package.  This will only work if you have already installed the package using `install.packages('packageName')`.  In other words, installing a package, and loading it using the `library()` function are separate actions.  You only have to install a function once, but you have to use `libary()` in every single R session or R script where you need access to those functions. 

### `filter()` 


The dplyr `filter()` function selects a subset of rows meeting some criterion.  Note that the result is a dataframe. Don't forget to click the "Run Code" button to see the result.  

```{r filter, exercise=TRUE}
filter(loans, School=="GEORGE WASHINGTON UNIVERSITY")
```

### `filter()` with multiple conditions

You can add multiple filter conditions.  You will get back all the rows for which all the conditions are `TRUE`. For example, the code below gives you all the public universities in DC (i.e.  the universities whose `State` is "DC" and whose `School_Type` is "Public"). Note: only one university meets these criteria.

```{r publicunis, exercise=TRUE}
filter(loans, State=="DC", School_Type=="Public")
```

### Be careful which `filter()` you are using

There is a base R function called `filter()` that does something completely different.  Be careful!  After you load the dplyr package using `library(dplyr)` then you will be using the correct function.  If you ever want to be 1000% sure, you can specify the package directly like this: `dplyr::filter()`. This `::` syntax doesn't load the entire package, it only applies to that single useage of the function.   

### Challenge

Use the `filter()` function to get the data for "AMERICAN UNIVERSITY". 

```{r fAM, exercise=TRUE}
## your code here
```

```{r fAM-solution}
filter(loans, Name=="AMERICAN UNIVERSITY")
```

### Double bonus challenge

Use the `filter()` function to get the data for GEORGE WASHINGTON UNIVERSITY and GALLAUDET UNIVERSITY in a single line of code. Hint: use the `%in%` operator instead of the `==` operator to pass a vector of possible school names rather than just a single school name.


```{r mult, exercise=TRUE}
## your answer here
```

```{r mult-solution}
filter(loans, Name %in% c("GEORGE WASHINGTON UNIVERSITY", "GALLAUDET UNIVERSITY"))
```


### `arrange()`

This function is like the "sort" function in MS Excel.  You simply provide a list of column names to sort by. Note, here we are sorting by the total amount of subsidized direct loans each school has.

```{r}
arrange(loans, State, SubsidizedDL)
arrange(loans, State, desc(SubsidizedDL))
```

### `select()`

This function pulls out columns of interest.  You can select ranges of columns using the `:` operator syntax. (Note: the `:` operator usually only works with numeric data, but this is a special usage defined in the `dplyr` package)

```{r}
select(loans, State, SubsidizedDL)
select(loans, -State, -SubsidizedDL)
select(loans, State:SubsidizedDL)
```

### `distinct()`

This function extracts the distinct rows. In other words, if two or more rows are identical, then `distinct()` removes the duplicates and returns a single row.  It is most often useful when combined with `select()` to find the unique combinations of some set of rows.

```{r}
distinct(loans)
distinct(select(loans, State, School_Type))
```

### `mutate()`

Adds new columns that are some function of existing columns

```{r}
mutate(loans, Total_Loans = SubsidizedDL + UNSubsidizedDL)
```

### `rowwise()`

Mutate works as expected when you want to manipulate whole columns at once, but sometimes you want to do something on a row-by-row basis.

For example: this code doesn't work as you might expect

```{r}
myDF <- data.frame(x=c(1,2,3), y=c(10, 11, 12))
mutate(myDF, sum=sum(x, y))
```

But the code below computes the sum on a row-by-row basis, as you might expect

```{r}
myDF <- data.frame(x=c(1,2,3), y=c(10, 11, 12))
mutate(rowwise(myDF), sum=sum(x, y))
```


### `summarise()`

Summarizes data into a single row.  This may seem not that useful, but it will become useful when we start grouping data. 

```{r}
summarise(loans, meanSubDL = mean(SubsidizedDL, na.rm=TRUE))
```


## Grouping Data

These functions above get really powerful when you start grouping data based on factors in your dataset.

##`group_by()`

```{r}
groupedLoans <- group_by(loans, State)
summarise(groupedLoans, meanSubDL = mean(SubsidizedDL, na.rm=TRUE))
```

## Chaining operations

`dplyr` also provides a way of chaining together complicated operations with the `%>%` operator.

This prevents having to save intermediate steps, or to have a complicated series of nested functions.

### Which is easier to read?

Both of the below options are equivalent ways of doing a series of operations in R.  Option 1 involves so-called "nested" function calls.  Option 2 uses the %>% operator to chain together operations, which makes for more intuitive code.


**Option 1**

```
leaveHouse(eatBreakfast(getOutOfBed(wakeUp())))
```

**Option 2**

```
wakeUp() %>% getOutOfBed() %>% eatBreafast() %>% leaveHouse()
```

Remember: the %>% operator is defined in the `dplyr` libary, so until you run the command `library(dplyr)`, you will get an error if you try to use the `%>%` operator.  

### A real example

Note that the resulting dataframe from each step is passed as the first argument to the next function in the chain. Notice how you can almost follow what is going on just by reading the code out loud:

```{r examp, exercise=TRUE}
meanTotalLoans <- 
  group_by(loans, School_Type) %>%
    mutate(Total_Loans = SubsidizedDL + UNSubsidizedDL) %>%
    select(-State) %>%
    summarise(mean_total_loans = mean(Total_Loans, na.rm=TRUE))
meanTotalLoans
```

In this example we haven't saved all the intermediate steps, so we don't have leftover dataframes floating around that are missing the State column. In the end, all we have is the `meanTotalLoans` dataframe we saved.



## Chaining works with non-`dplyr()` functions too

```{r warning=FALSE}
#chained syntax
rnorm(1000, mean=20, sd=1.4) %>% log %>% hist(main="my nice histogram")


#compare with nested function calls 

hist(log(rnorm(1000, mean=20, sd=1.4)))
```

## `do()`

do anything to grouped data

```{r}
linearModels <- loans %>% group_by(State) %>%
  do(regression=lm(UNSubsidizedDL~SubsidizedDL, data=.))
linearModels
```

## `do()`


<pre class="prettyprint lang-r">
linearModels <- loans %>% group_by(State) %>%
  do(regression=lm(UNSubsidizedDL~SubsidizedDL, data=.))
linearModels
</pre>

```{r}
linearModels %>% 
  summarize(sum=summary(regression)$r.squared)
```


## Challenge

Using the `diamonds` dataset that is built in to the `ggplot2` package:

*  calculate the mean price of diamonds for each of the different clarity ratings
*  create a new column called `volume` that is the product of x, y and z
*  plot `volume` against `carat`

## More info

A more complete introduction is available in the [`dplyr` vignette](http://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html)

More info on `magrittr` [can be found here](http://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html).
