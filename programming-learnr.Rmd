---
title: "programing in R"
author: Andrew Barr
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---


## Programming in R

R is a legit programming language, which means that it gives you all the tools you need to automate repetitive tasks.  There are three (or more) main ways to do this:


* `for` loops
* the `lapply()` function
* the `tidyverse`

## for loops

`for` loops will be familiar if you have ever used any other programming languages.  The basic structure looks like this:

```{r results='hide'}
vector <- 1:10
for(i in vector){
  #do something with i
}
```

### More complicated

Here is a (slightly) more complicated example. 

```{r for, exercise=TRUE}
myVector <- 1:10
for(counter in myVector){
  result <- paste("counter ^ 2 = ", counter^2)
  print(result)
}
```

Explanation in English:

-  We loop over a vector `1:100`, and sequentially assign its values to a temporary variable we are calling `counter`. (Note: we can call this variable whatever we want.) 
-  Then, R does what is within the curly braces `{}` for each iteration of the loop.
-  In this case, it pastes together some text with the square of the value of `counter` and prints this all to the console. 

*Question*: After running the above code, what is the value of `counter`? What is the value of `myVector`? Has this value changed? Don't forget to click the "Run Code" button.

### getting stuff out of a loop

First, Create a results vector in advance that is the same length as the vector we are looping over

Then save the results each time in the appropriate slot. 

Note in the example below, we are using the `numeric()` function to create an empty numeric vector. Also, notice we don't tell `numeric()` the length of the new vector directly, we ask it to look at the length of `myvector` and make `results` vector the same length. This is a nice trick, because it means you don't need to know the length of the results vector in advance. 

```{r}
numbers <- 1:5
results <- numeric(length(numbers)) 
for(each in myVector){
  numbers[each] <- paste(myVector[each], "^ 2 = ", myVector[each]^2)
}

numbers

```

### `if` statements

-  Often during a loop, you may want to do a test and do something different based on the results of the test. 
-  Imagine a vector of germination outcomes from a seed experiment. 
-  0 indicates the seed did not germinate due to insect predation
-  1 indicates that it did not germinate but no insect predation occurred
-  2 indicates that the seed germinated. 

We can use the `if()` function to evaluate the outcome and provide context specific output. 

---

```{r}
outcomes <- c(0,1,0,2,0,1,0,2,0,1,0,1,0,0)
for(trial in outcomes){
  if(trial == 2) print("Welcome to the world, plantling!")
  else print("RIP")
}
```

## Challenge

Write a `for` loop to examine the law of large numbers to illustrate how, as sample size increases, estimates of the mean of a population converge on the true value.  Do this in the following steps:

* create a numeric results vector of length 2000
* loop over each integer `i` from 1 to 2000
* at each iteration use the `rnorm()` function to simulate a sample of size `i` from a population with a mean of 100 and standard deviation of 30.
* calculate the mean of this sample, and be sure to save these results to the appropriate place in the results vector
* finally, make a plot of the results with the integers 1 to 2000 on the x axis, and the corresponding value from the results vector on the y axis

<!-- ## solution -->

<!-- ```{r} -->
<!-- results <- numeric(2000) -->
<!-- for(i in 1:2000){ -->
<!--   results[i] <- mean(rnorm(n=i, mean=100, sd=30)) -->
<!-- } -->
<!-- plot(1:2000, results, pch=16) -->
<!-- ``` -->


## `lapply()`

<div class="columns-2">

The function `lapply()` is like a `for` loop, but is optimized and explicitly functional.

`lapply()` usually takes two arguments 

-  `X` which is a list or a vector to loop over
-  `FUN` which is a function to apply to each element of `X`.  

Thus, `FUN` must be able to accept any element of `X` as an argument. 

```{r}
x <- c("dog","cat", "cucumber")
lapply(x, FUN=nchar)
```
</div>

## Writing your own functions


Functions are the best way to encapsulate code that you want to repeat again and again.  

A function accepts **arguments** and **returns** a single (and only a single) object.

Variable names defined within a function only exist within the function (not within the global environment). 

## Writing your own functions

```{r}
is.even <- function(number){
  if(number %% 2 == 0) {return("The number is even")}
  else {return("The number is not even")}
}

is.even(1233)
is.even(1234)
is.even(-1.2)
```

## Lists

The "l" in `lapply()` stands for "list", because that's what you get as a result. 

**lists can hold any type of data, not every element needs to be the same type.**

```{r}
myList <- list(firstOne=1, nextOne="too", lastOne=rnorm(10))
myList
```

## often use double brackets `[[]]` to index a list

```{r}
myList[[3]]
myList[3]
```

For five marks....what is the difference?

## `[[]]` versus `[]`


<img src='../../images/pepper.png' width=900>


## lists can (optionally) have named elements, that can be accessed using the `$` operator 

```{r}
myList$nextOne
```

Where have you seen the `$` operator before?

What does this suggest about the relationship between list and dataframes?

## Lists are useful because of their flexibility. 

We can store complex results from each iteration, and then come back to these results later. 

```{r}
# note, we must accept an argument
# even if we don't do anything with this argument.
summarizeRandom <- function(n){
  sample <- rnorm(n)
  mySummary <- summary(sample)
  return(mySummary)
}

sampleSizes <- 100:200
myResults <- lapply(sampleSizes, FUN=summarizeRandom)
myResults[1:3]
```
